package db

import (
	"database/sql"
	"errors"
	"fmt"
	"log"
	"os"
	"reflect"
	"sort"
	"strings"
	"testing"
	"time"

	"vickgenda-cli/internal/models"

	"github.com/google/uuid"
	_ "github.com/mattn/go-sqlite3"
)

// TestMain sets up an in-memory SQLite database for testing.
func TestMain(m *testing.M) {
	os.Setenv("GO_ENV", "test")
	err := InitDB("file::memory:?cache=shared")
	if err != nil {
		log.Fatalf("Failed to initialize in-memory database for testing: %v", err)
	}
	exitCode := m.Run()
	if db != nil {
		err := db.Close()
		if err != nil {
			log.Printf("Error closing the database connection: %v", err)
		}
	}
	os.Exit(exitCode)
}

func clearQuestionsTable() error {
	if db == nil {
		log.Println("Database not initialized, skipping clearQuestionsTable")
		return nil
	}
	_, err := db.Exec("DELETE FROM questions")
	if err != nil {
		return err
	}
	return nil
}

func TestDatabaseInitialization(t *testing.T) {
	if db == nil {
		t.Fatal("Database (db) is nil after TestMain setup")
	}
	err := db.Ping()
	if err != nil {
		t.Fatalf("Failed to ping database: %v", err)
	}
	t.Log("In-memory database initialized and accessible.")
}

// --- Tests for CreateQuestion ---
func TestCreateQuestion_Success(t *testing.T) {
	if err := clearQuestionsTable(); err != nil {
		t.Fatalf("Failed to clear questions table: %v", err)
	}
	now := time.Now().UTC().Truncate(time.Second)
	inputQuestion := models.Question{
		Subject:        "Math", Topic: "Algebra", Difficulty: "Medium", QuestionText: "What is 2 + 2?",
		AnswerOptions:  []string{"3", "4", "5"}, CorrectAnswers: []string{"4"}, QuestionType:   models.QuestionTypeMultipleChoice,
		Source: "Textbook A", Tags: []string{"arithmetic", "basic"}, Author: "Test Author", LastUsedAt: now,
	}
	id, err := CreateQuestion(inputQuestion)
	if err != nil { t.Fatalf("CreateQuestion() returned error: %v", err) }
	if id == "" { t.Fatal("CreateQuestion() returned empty ID") }
	retrievedQuestion, err := GetQuestion(id)
	if err != nil { t.Fatalf("GetQuestion() returned error: %v", err) }

	if retrievedQuestion.ID != id || retrievedQuestion.Subject != inputQuestion.Subject {
		t.Errorf("Mismatch in created vs retrieved. Got ID %s, Subject %s", retrievedQuestion.ID, retrievedQuestion.Subject)
	}
	if !retrievedQuestion.LastUsedAt.UTC().Truncate(time.Second).Equal(now) {
		t.Errorf("LastUsedAt mismatch. Got %v, want %v", retrievedQuestion.LastUsedAt, now)
	}
	if retrievedQuestion.CreatedAt.IsZero() { t.Error("Retrieved CreatedAt is zero") }
}

func TestCreateQuestion_AutoGeneratedFields(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	inputQuestion := models.Question{ Subject: "Science", Topic: "Physics", Difficulty: "Hard", QuestionText:   "What is the speed of light?", CorrectAnswers: []string{"299,792,458 m/s"}, QuestionType:   models.QuestionTypeShortAnswer, }
	id, err := CreateQuestion(inputQuestion)
	if err != nil { t.Fatalf("CreateQuestion() returned error: %v", err) }
	if id == "" { t.Fatal("CreateQuestion() returned empty ID") }
	retrievedQuestion, err := GetQuestion(id)
	if err != nil { t.Fatalf("GetQuestion() returned error: %v", err) }
	if retrievedQuestion.ID != id { t.Errorf("Retrieved ID mismatch") }
	if retrievedQuestion.CreatedAt.IsZero() { t.Error("Retrieved CreatedAt is zero") }
	if time.Since(retrievedQuestion.CreatedAt.UTC()) > 5*time.Second { t.Errorf("Retrieved CreatedAt = %v, seems too old", retrievedQuestion.CreatedAt) }
}

func TestCreateQuestion_EmptySlicesAndZeroTimes(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	inputQuestion := models.Question{ Subject: "History", Topic: "Ancient Civilizations", Difficulty: "Easy", QuestionText: "Longest river?", AnswerOptions:  []string{}, CorrectAnswers: []string{"Nile"}, QuestionType: models.QuestionTypeMultipleChoice, Tags: nil, LastUsedAt: time.Time{}, }
	id, err := CreateQuestion(inputQuestion)
	if err != nil { t.Fatalf("CreateQuestion() returned error: %v", err) }
	retrievedQuestion, err := GetQuestion(id)
	if err != nil { t.Fatalf("GetQuestion() returned error: %v", err) }
	if !(retrievedQuestion.AnswerOptions != nil && len(retrievedQuestion.AnswerOptions) == 0) { t.Errorf("AnswerOptions not empty non-nil slice: %#v", retrievedQuestion.AnswerOptions) }
	if retrievedQuestion.Tags != nil { t.Errorf("Tags not nil: %#v", retrievedQuestion.Tags) }
	if !retrievedQuestion.LastUsedAt.IsZero() { t.Errorf("LastUsedAt not zero: %v", retrievedQuestion.LastUsedAt) }
}

// --- Tests for GetQuestion ---
func TestGetQuestion_Success(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	initialTime := time.Now().UTC().Truncate(time.Second)
	createdQuestion := models.Question{ Subject: "Cosmology", LastUsedAt: initialTime, CorrectAnswers: []string{"CMB"}, QuestionType: models.QuestionTypeShortAnswer }
	id, _ := CreateQuestion(createdQuestion)
	dbCreatedQuestion, _ := GetQuestion(id)
	retrievedQ, err := GetQuestion(id)
	if err != nil { t.Fatalf("GetQuestion(%q) failed: %v", id, err) }
	if !reflect.DeepEqual(retrievedQ, dbCreatedQuestion) { t.Errorf("GetQuestion returned different data. Initial: %#v, Second: %#v", dbCreatedQuestion, retrievedQ) }
}

func TestGetQuestion_NotFound(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	_, err := GetQuestion(uuid.NewString())
	if !errors.Is(err, sql.ErrNoRows) { t.Errorf("Expected sql.ErrNoRows, got: %v", err) }
}

// --- Tests for UpdateQuestion ---
func TestUpdateQuestion_Success(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	qInitial := models.Question{ Subject: "Initial", Topic: "Initial", Difficulty: models.DifficultyEasy, QuestionText: "Initial?", CorrectAnswers: []string{"Initial"}, QuestionType: models.QuestionTypeShortAnswer, CreatedAt: time.Now().UTC().Truncate(time.Second) }
	id, _ := CreateQuestion(qInitial)
	qCreated, _ := GetQuestion(id)
	originalCreatedAt := qCreated.CreatedAt.UTC().Truncate(time.Second)
	qUpdated := models.Question{ ID: id, Subject: "Updated", CreatedAt: originalCreatedAt, CorrectAnswers: []string{"Updated"}, QuestionType: models.QuestionTypeShortAnswer }
	err := UpdateQuestion(qUpdated)
	if err != nil { t.Fatalf("UpdateQuestion failed: %v", err) }
	qRetrieved, _ := GetQuestion(id)
	if qRetrieved.Subject != "Updated" { t.Errorf("Subject not updated") }
	if !qRetrieved.CreatedAt.Equal(originalCreatedAt) { t.Errorf("CreatedAt changed") }
}

func TestUpdateQuestion_NonExistent(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	qNonExistent := models.Question{ ID: uuid.NewString(), Subject: "NonExistent", CorrectAnswers: []string{"A"}, QuestionType: "T", CreatedAt: time.Now() }
	err := UpdateQuestion(qNonExistent)
	if err == nil || !strings.Contains(err.Error(), "no question found with ID") { t.Errorf("Expected 'no question found' error, got %v", err) }
}

func TestUpdateQuestion_EmptyID(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	qNoID := models.Question{ ID: "", Subject: "NoID", CorrectAnswers: []string{"A"}, QuestionType: "T", CreatedAt: time.Now() }
	err := UpdateQuestion(qNoID)
	if err == nil || !strings.Contains(err.Error(), "cannot update question without ID") { t.Errorf("Expected 'cannot update without ID' error, got %v", err) }
}

// --- Tests for DeleteQuestion ---
func TestDeleteQuestion_Success(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	q1 := models.Question{ Subject: "ToDelete", CorrectAnswers: []string{"A"}, QuestionType: "T", CreatedAt: time.Now() }
	id, _ := CreateQuestion(q1)
	err := DeleteQuestion(id)
	if err != nil { t.Fatalf("DeleteQuestion failed: %v", err) }
	_, err = GetQuestion(id)
	if !errors.Is(err, sql.ErrNoRows) { t.Errorf("Expected sql.ErrNoRows after delete, got %v", err) }
}

func TestDeleteQuestion_NonExistent(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	err := DeleteQuestion(uuid.NewString())
	if !errors.Is(err, sql.ErrNoRows) { t.Errorf("Expected sql.ErrNoRows for non-existent delete, got %v", err) }
}

func TestDeleteQuestion_EmptyID(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	err := DeleteQuestion("")
	if err == nil || err.Error() != "cannot delete question without ID: ID cannot be empty" { t.Errorf("Expected specific empty ID error, got %v", err) }
}

// --- Helper for ListQuestions tests ---
func createNSampleQuestions(t *testing.T, n int, subjectPrefix string) []models.Question {
	t.Helper()
	var questions []models.Question
	baseTime := time.Now().UTC().Truncate(time.Second)
	for i := 0; i < n; i++ {
		createdAt := baseTime.Add(time.Duration(i-n) * time.Hour)
		q := models.Question{ Subject: fmt.Sprintf("%s %d", subjectPrefix, i+1), Topic: "List Test Topic", Difficulty: models.DifficultyEasy, QuestionText:   fmt.Sprintf("List test question %d?", i+1), CorrectAnswers: []string{fmt.Sprintf("Answer %d", i+1)}, QuestionType: models.QuestionTypeShortAnswer, CreatedAt: createdAt, }
		id, err_create := CreateQuestion(q)
		if err_create != nil { t.Fatalf("Helper CreateQuestion failed: %v", err_create) }
		createdQ, err_get := GetQuestion(id)
		if err_get != nil { t.Fatalf("Helper GetQuestion failed: %v", err_get) }
		questions = append(questions, createdQ)
	}
	sort.Slice(questions, func(i, j int) bool { return questions[i].CreatedAt.Before(questions[j].CreatedAt) })
	return questions
}

// --- Tests for ListQuestions (Pagination & Defaults) ---
func TestListQuestions_NoQuestions(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	listed, total, err := ListQuestions(map[string]interface{}{}, "", "", 10, 1)
	if err != nil { t.Fatalf("ListQuestions failed: %v", err) }
	if len(listed) != 0 || total != 0 { t.Errorf("Expected 0 questions and total 0, got len %d, total %d", len(listed), total) }
}

func TestListQuestions_ListAllDefaultSort(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	localSample := createNSampleQuestions(t, 3, "DefaultSort")
	expectedOrder := []models.Question{localSample[2], localSample[1], localSample[0]}
	listed, total, err := ListQuestions(map[string]interface{}{}, "", "", 10, 1)
	if err != nil { t.Fatalf("ListQuestions failed: %v", err) }
	if total != 3 || len(listed) != 3 { t.Fatalf("Expected total 3, len 3. Got total %d, len %d", total, len(listed)) }
	for i, eq := range expectedOrder { if listed[i].ID != eq.ID { t.Errorf("Default sort error at index %d. Got %s, want %s", i, listed[i].Subject, eq.Subject) } }
}

func TestListQuestions_Pagination(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	allQs := createNSampleQuestions(t, 5, "Pagination")
	l, tt, e := ListQuestions(map[string]interface{}{}, "created_at", "ASC", 2, 1)
	if e != nil || tt != 5 || len(l) != 2 || l[0].ID != allQs[0].ID || l[1].ID != allQs[1].ID { t.Errorf("P1 L2 ASC failed. E: %v, T:%d, L:%d, IDs: %s,%s / %s,%s", e,tt,len(l), l[0].ID, l[1].ID, allQs[0].ID, allQs[1].ID ) }
	l, tt, e = ListQuestions(map[string]interface{}{}, "created_at", "ASC", 2, 2)
	if e != nil || tt != 5 || len(l) != 2 || l[0].ID != allQs[2].ID || l[1].ID != allQs[3].ID { t.Errorf("P2 L2 ASC failed. E: %v, T:%d, L:%d, IDs: %s,%s / %s,%s", e,tt,len(l), l[0].ID, l[1].ID, allQs[2].ID, allQs[3].ID ) }
	l, tt, e = ListQuestions(map[string]interface{}{}, "created_at", "ASC", 2, 3)
	if e != nil || tt != 5 || len(l) != 1 || l[0].ID != allQs[4].ID { t.Errorf("P3 L2 ASC failed. E: %v, T:%d, L:%d, ID: %s / %s", e,tt,len(l), l[0].ID, allQs[4].ID) }
}

func TestListQuestions_DefaultLimitAndPage(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	_ = createNSampleQuestions(t, 25, "DefaultLimitPage")
	l, tt, e := ListQuestions(map[string]interface{}{}, "", "", 0, 0)
	if e != nil || tt != 25 || len(l) != 20 { t.Errorf("Default 0,0 failed. E:%v, T:%d, L:%d", e,tt,len(l)) }
	l, tt, e = ListQuestions(map[string]interface{}{}, "", "", 10, 0)
	if e != nil || tt != 25 || len(l) != 10 { t.Errorf("Default 10,0 failed. E:%v, T:%d, L:%d", e,tt,len(l)) }
}

// --- Tests for ListQuestions Filtering ---
func containsQuestionID(questions []models.Question, id string) bool {
	for _, q := range questions { if q.ID == id { return true } }
	return false
}

func TestListQuestions_FilterBySubject(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	m1ID, _ := CreateQuestion(models.Question{Subject: "Math", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	_, _ = CreateQuestion(models.Question{Subject: "Science", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	m2ID, _ := CreateQuestion(models.Question{Subject: "Math", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	l, tt, e := ListQuestions(map[string]interface{}{"subject": "Math"}, "", "", 10, 1)
	if e != nil || tt != 2 || len(l) != 2 || !containsQuestionID(l, m1ID) || !containsQuestionID(l, m2ID) { t.Errorf("Filter Subject 'Math' failed. E:%v, T:%d, L:%d", e,tt,len(l)) }
}

func TestListQuestions_FilterByTopic(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	a1ID, _ := CreateQuestion(models.Question{Topic: "Algebra", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	_, _ = CreateQuestion(models.Question{Topic: "Geometry", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	a2ID, _ := CreateQuestion(models.Question{Topic: "Algebra", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	l, tt, e := ListQuestions(map[string]interface{}{"topic": "Algebra"}, "", "", 10, 1)
	if e != nil || tt != 2 || len(l) != 2 || !containsQuestionID(l, a1ID) || !containsQuestionID(l, a2ID) { t.Errorf("Filter Topic 'Algebra' failed. E:%v, T:%d, L:%d", e,tt,len(l)) }
}

func TestListQuestions_FilterByDifficulty(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	e1ID, _ := CreateQuestion(models.Question{Difficulty: models.DifficultyEasy, CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	_, _ = CreateQuestion(models.Question{Difficulty: models.DifficultyHard, CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	e2ID, _ := CreateQuestion(models.Question{Difficulty: models.DifficultyEasy, CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	l, tt, e := ListQuestions(map[string]interface{}{"difficulty": models.DifficultyEasy}, "", "", 10, 1)
	if e != nil || tt != 2 || len(l) != 2 || !containsQuestionID(l, e1ID) || !containsQuestionID(l, e2ID) { t.Errorf("Filter Difficulty '%s' failed. E:%v, T:%d, L:%d", models.DifficultyEasy, e,tt,len(l)) }
}

func TestListQuestions_FilterByQuestionType(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	mc1ID, _ := CreateQuestion(models.Question{QuestionType: models.QuestionTypeMultipleChoice, CorrectAnswers: []string{"a"}, CreatedAt: time.Now()})
	_, _ = CreateQuestion(models.Question{QuestionType: models.QuestionTypeEssay, CorrectAnswers: []string{"a"}, CreatedAt: time.Now()})
	mc2ID, _ := CreateQuestion(models.Question{QuestionType: models.QuestionTypeMultipleChoice, CorrectAnswers: []string{"a"}, CreatedAt: time.Now()})
	l, tt, e := ListQuestions(map[string]interface{}{"question_type": models.QuestionTypeMultipleChoice}, "", "", 10, 1)
	if e != nil || tt != 2 || len(l) != 2 || !containsQuestionID(l, mc1ID) || !containsQuestionID(l, mc2ID) { t.Errorf("Filter Type '%s' failed. E:%v, T:%d, L:%d", models.QuestionTypeMultipleChoice, e,tt,len(l)) }
}

func TestListQuestions_FilterByAuthor(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	authA1ID, _ := CreateQuestion(models.Question{Author: "Alice", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	_, _ = CreateQuestion(models.Question{Author: "Bob", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	authA2ID, _ := CreateQuestion(models.Question{Author: "Alice", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	l, tt, e := ListQuestions(map[string]interface{}{"author": "Alice"}, "", "", 10, 1)
	if e != nil || tt != 2 || len(l) != 2 || !containsQuestionID(l, authA1ID) || !containsQuestionID(l, authA2ID) { t.Errorf("Filter Author 'Alice' failed. E:%v, T:%d, L:%d", e,tt,len(l)) }
}

func TestListQuestions_FilterByTags(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	q1ID, _ := CreateQuestion(models.Question{Tags: []string{"calculus", "derivative"}, Subject: "TagTest1", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	q2ID, _ := CreateQuestion(models.Question{Tags: []string{"algebra", "equation"}, Subject: "TagTest2", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	q3ID, _ := CreateQuestion(models.Question{Tags: []string{"calculus", "integral"}, Subject: "TagTest3", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})

	lCalc, ttCalc, eCalc := ListQuestions(map[string]interface{}{"tags": "calculus"}, "", "", 10, 1)
	if eCalc != nil || ttCalc != 2 || len(lCalc) != 2 || !containsQuestionID(lCalc, q1ID) || !containsQuestionID(lCalc, q3ID) { t.Errorf("Filter Tag 'calculus' failed. E:%v, T:%d, L:%d", eCalc,ttCalc,len(lCalc)) }

	lDeriv, ttDeriv, eDeriv := ListQuestions(map[string]interface{}{"tags": "derivative"}, "", "", 10, 1)
	if eDeriv != nil || ttDeriv != 1 || len(lDeriv) != 1 || !containsQuestionID(lDeriv, q1ID) { t.Errorf("Filter Tag 'derivative' failed. E:%v, T:%d, L:%d", eDeriv,ttDeriv,len(lDeriv)) }

	lAlg, ttAlg, eAlg := ListQuestions(map[string]interface{}{"tags": "algebra"}, "", "", 10, 1) // This uses q2ID
	if eAlg != nil || ttAlg != 1 || len(lAlg) != 1 || !containsQuestionID(lAlg, q2ID) { t.Errorf("Filter Tag 'algebra' failed. E:%v, T:%d, L:%d", eAlg,ttAlg,len(lAlg)) }

	lNon, ttNon, eNon := ListQuestions(map[string]interface{}{"tags": "nonexistenttag"}, "", "", 10, 1)
	if eNon != nil || ttNon != 0 || len(lNon) != 0 { t.Errorf("Filter Tag 'nonexistenttag' failed. E:%v, T:%d, L:%d", eNon,ttNon,len(lNon)) }
}

func TestListQuestions_FilterByMultipleFields(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	qAID, _ := CreateQuestion(models.Question{Subject: "Math", Topic: "Algebra", Difficulty: models.DifficultyEasy, Author: "Carol", QuestionText: "qA", CorrectAnswers: []string{"a"}, QuestionType: models.QuestionTypeShortAnswer, CreatedAt: time.Now()})
	qBID, _ := CreateQuestion(models.Question{Subject: "Math", Topic: "Algebra", Difficulty: models.DifficultyHard, Author: "Carol", QuestionText: "qB", CorrectAnswers: []string{"a"}, QuestionType: models.QuestionTypeShortAnswer, CreatedAt: time.Now()})
	_, _ = CreateQuestion(models.Question{Subject: "Science", Topic: "Physics", Difficulty: models.DifficultyEasy, Author: "Dave", QuestionText: "qC", CorrectAnswers: []string{"a"}, QuestionType: models.QuestionTypeShortAnswer, CreatedAt: time.Now()})

	f1 := map[string]interface{}{"subject": "Math", "difficulty": models.DifficultyEasy}
	l1, tt1, e1 := ListQuestions(f1, "", "", 10, 1)
	if e1 != nil || tt1 != 1 || len(l1) != 1 || !containsQuestionID(l1, qAID) { t.Errorf("Filter (Math, Easy) failed. E:%v, T:%d, L:%d", e1,tt1,len(l1)) }

	f2 := map[string]interface{}{"subject": "Math", "author": "Carol"}
	l2, tt2, e2 := ListQuestions(f2, "", "", 10, 1)
	if e2 != nil || tt2 != 2 || len(l2) != 2 || !containsQuestionID(l2, qAID) || !containsQuestionID(l2, qBID) { t.Errorf("Filter (Math, Carol) failed. E:%v, T:%d, L:%d", e2,tt2,len(l2)) }

	f3 := map[string]interface{}{"subject": "NonExistent", "author": "Carol"}
	l3, tt3, e3 := ListQuestions(f3, "", "", 10, 1)
	if e3 != nil || tt3 != 0 || len(l3) != 0 { t.Errorf("Filter (NonExistent, Carol) failed. E:%v, T:%d, L:%d", e3,tt3,len(l3)) }
}

// --- Tests for ListQuestions Searching ---
// (Search tests from previous step would be here if not consolidating, they are assumed to be passing and present)
func TestListQuestions_Search_SingleField(t *testing.T) {
	if err := clearQuestionsTable(); err != nil {t.Fatalf("clear table: %v", err)}
	q1ID, _ := CreateQuestion(models.Question{Subject: "Mathmatics", QuestionText: "What is 2+2?", Author: "Newton", CorrectAnswers: []string{"4"}, QuestionType: "calc", CreatedAt: time.Now()})
	q2ID, _ := CreateQuestion(models.Question{Subject: "Physics", QuestionText: "Explain gravity.", Author: "Einstein", CorrectAnswers: []string{"E=mc^2"}, QuestionType: "theory", CreatedAt: time.Now()})
	q3ID, _ := CreateQuestion(models.Question{Subject: "Math", QuestionText: "Solve for x in x+5=10.", Author: "Euclid", CorrectAnswers: []string{"5"}, QuestionType: "algebra", CreatedAt: time.Now()})

	l, tt, e := ListQuestions(map[string]interface{}{"search_query": "Math", "search_fields": []string{"subject"}}, "", "", 10, 1)
	if e != nil || tt != 2 || len(l) != 2 || !containsQuestionID(l, q1ID) || !containsQuestionID(l, q3ID) {t.Errorf("Search Subject 'Math' failed. E:%v T:%d L:%d", e, tt, len(l))}

	l, tt, e = ListQuestions(map[string]interface{}{"search_query": "gravity", "search_fields": []string{"question_text"}}, "", "", 10, 1)
	if e != nil || tt != 1 || len(l) != 1 || !containsQuestionID(l, q2ID) {t.Errorf("Search QuestionText 'gravity' failed. E:%v T:%d L:%d", e, tt, len(l))}

	l, tt, e = ListQuestions(map[string]interface{}{"search_query": "Newton", "search_fields": []string{"author"}}, "", "", 10, 1)
	if e != nil || tt != 1 || len(l) != 1 || !containsQuestionID(l, q1ID) {t.Errorf("Search Author 'Newton' failed. E:%v T:%d L:%d", e, tt, len(l))}
}

func TestListQuestions_Search_MultipleFields(t *testing.T) {
	if err := clearQuestionsTable(); err != nil {t.Fatalf("clear table: %v", err)}
	q1ID, _ := CreateQuestion(models.Question{Subject: "Mathmatics", QuestionText: "What is 2+2?", Author: "Newton", CorrectAnswers: []string{"4"}, QuestionType: "calc", CreatedAt: time.Now()})
	q2ID, _ := CreateQuestion(models.Question{Subject: "Physics", QuestionText: "Explain gravity.", Author: "Einstein", CorrectAnswers: []string{"E=mc^2"}, QuestionType: "theory", CreatedAt: time.Now()}) // Gave ID to q2
	q3ID, _ := CreateQuestion(models.Question{Subject: "Math", QuestionText: "Solve for x in x+5=10.", Author: "Euclid", Topic: "Algebra basics", CorrectAnswers: []string{"5"}, QuestionType: "algebra", CreatedAt: time.Now()})

	l, tt, e := ListQuestions(map[string]interface{}{"search_query": "Math", "search_fields": []string{"subject", "question_text"}}, "", "", 10, 1)
	if e != nil || tt != 2 || len(l) != 2 || !containsQuestionID(l, q1ID) || !containsQuestionID(l, q3ID) {t.Errorf("Search 'Math' in Subject,QuestionText failed. E:%v T:%d L:%d", e,tt,len(l))}

	// Corrected assertion: Expect q2ID and q3ID for search query "x" in topic or question_text
	l, tt, e = ListQuestions(map[string]interface{}{"search_query": "x", "search_fields": []string{"topic", "question_text"}}, "", "", 10, 1)
	if e != nil || tt != 2 || len(l) != 2 || !containsQuestionID(l, q2ID) || !containsQuestionID(l, q3ID) {t.Errorf("Search 'x' in Topic,QuestionText failed. Expected q2ID, q3ID. E:%v T:%d L:%d. Found IDs: %v", e,tt,len(l), listedIDs(l))}
}

// Helper function to get IDs from a slice of questions for easier debugging
func listedIDs(questions []models.Question) []string {
	ids := make([]string, len(questions))
	for i, q := range questions {
		ids[i] = q.ID
	}
	return ids
}

func TestListQuestions_Search_AcrossAllValidFields(t *testing.T) {
    if err := clearQuestionsTable(); err != nil { t.Fatalf("clear table: %v", err) }
    uniqueID := "searchmeexactly"
    qSearchAll := models.Question{
        ID: uniqueID, Subject: "UniqueSubj", Topic: "UniqueTopic", QuestionText: "Unique text content here.",
        Source: "UniqueSource", Tags: []string{"tagunique"}, Author: "UniqueAuthor", Difficulty: models.DifficultyEasy, QuestionType: models.QuestionTypeEssay,
		CorrectAnswers: []string{"ans"}, CreatedAt: time.Now(),
    }
    _, err := CreateQuestion(qSearchAll) // CreateQuestion generates its own ID, so we use the one it returns
	if err != nil {t.Fatalf("Failed to create qSearchAll: %v", err)}

	// Fetch the actual created question to get its actual ID
	qCreated, err := GetQuestion(uniqueID) // Use the ID we tried to set.
	if err != nil { // If not found by that ID, it means CreateQuestion used another.
		// This part is tricky if CreateQuestion *always* overwrites ID. Assuming it does for now.
		// For this test to be robust, we'd need CreateQuestion to allow setting ID or find by another field.
		// For now, we'll assume the test setup is fine and CreateQuestion allowed setting the ID.
		// If CreateQuestion *always* generates a new ID, this test needs rethink on how to find qSearchAll.
		// Let's assume for now CreateQuestion will use provided ID if not empty.
		// The original code for CreateQuestion: if q.ID == "" { q.ID = uuid.NewString() }
		// So, providing an ID should make it use that ID.
		 t.Fatalf("Failed to get qSearchAll by specific ID for validation: %v", err)
	}


    allSearchableFields := []string{"id", "subject", "topic", "question_text", "source", "tags", "author", "difficulty", "question_type"}
    searchTerms := map[string]string{
        "ID": qCreated.ID, "Subject": "UniqueSubj", "Topic": "UniqueTopic", "QuestionText": "content here",
        "Source": "UniqueSource", "Tags": "tagunique", "Author": "UniqueAuthor", "Difficulty": models.DifficultyEasy, "QuestionType": models.QuestionTypeEssay,
    }

    for fieldName, term := range searchTerms {
        l, tt, e := ListQuestions(map[string]interface{}{"search_query": term, "search_fields": allSearchableFields}, "", "", 10, 1)
        if e != nil { t.Errorf("Search all for term '%s' (field %s) failed: %v", term, fieldName, e) ; continue }
        if tt != 1 || len(l) != 1 { t.Errorf("Search all for term '%s' (field %s): Expected 1 result, got total %d, len %d", term, fieldName, tt, len(l)) ; continue}
        if !containsQuestionID(l, qCreated.ID) { t.Errorf("Search all for term '%s' (field %s): Did not find question ID %s", term, fieldName, qCreated.ID) }
    }
}


func TestListQuestions_Search_InvalidSearchField(t *testing.T) {
	if err := clearQuestionsTable(); err != nil {t.Fatalf("clear table: %v", err)}
	_, _, err := ListQuestions(map[string]interface{}{"search_query": "test", "search_fields": []string{"non_existent_field"}}, "", "", 10, 1)
	if err == nil || !strings.Contains(err.Error(), "invalid search_field provided") {
		t.Errorf("Expected 'invalid search_field' error, got %v", err)
	}
}

func TestListQuestions_Search_NoResults(t *testing.T) {
	if err := clearQuestionsTable(); err != nil {t.Fatalf("clear table: %v", err)}
	_, _ = CreateQuestion(models.Question{Subject: "Existing", QuestionText: "Content", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	l, tt, e := ListQuestions(map[string]interface{}{"search_query": "NonExistentTerm", "search_fields": []string{"subject", "question_text"}}, "", "", 10, 1)
	if e != nil {t.Fatalf("Search NoResults failed: %v", e)}
	if tt != 0 || len(l) != 0 {t.Errorf("Search NoResults: Expected 0 results, got total %d, len %d", tt, len(l))}
}

func TestListQuestions_Search_CombinedWithFilter(t *testing.T) {
	if err := clearQuestionsTable(); err != nil {t.Fatalf("clear table: %v", err)}
	qF1ID, _ := CreateQuestion(models.Question{Subject: "History", Topic: "Ancient", QuestionText: "About Rome", Difficulty: models.DifficultyEasy, CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	_, _ = CreateQuestion(models.Question{Subject: "History", Topic: "Modern", QuestionText: "About Revolution", Difficulty: models.DifficultyHard, CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	qF3ID, _ := CreateQuestion(models.Question{Subject: "Math", Topic: "Algebra", QuestionText: "Solve equation for Rome", Difficulty: models.DifficultyEasy, CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})

	filters1 := map[string]interface{}{"subject": "History", "search_query": "Rome", "search_fields": []string{"question_text"}}
	l1, tt1, e1 := ListQuestions(filters1, "", "", 10, 1)
	if e1 != nil || tt1 != 1 || len(l1) != 1 || !containsQuestionID(l1, qF1ID) {t.Errorf("Search+Filter (History, Rome) failed. E:%v T:%d L:%d", e1,tt1,len(l1))}

	filters2 := map[string]interface{}{"difficulty": models.DifficultyEasy, "search_query": "Rome", "search_fields": []string{"question_text", "subject", "topic"}}
	l2, tt2, e2 := ListQuestions(filters2, "", "", 10, 1)
	if e2 != nil || tt2 != 2 || len(l2) != 2 || !containsQuestionID(l2, qF1ID) || !containsQuestionID(l2, qF3ID) {t.Errorf("Search+Filter (Easy, Rome) failed. E:%v T:%d L:%d", e2,tt2,len(l2))}
}

// --- Tests for ListQuestions Sorting ---

func TestListQuestions_SortBySubject(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	qBioID, _ := CreateQuestion(models.Question{Subject: "Biology", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	qChemID, _ := CreateQuestion(models.Question{Subject: "Chemistry", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	qPhysID, _ := CreateQuestion(models.Question{Subject: "Physics", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})

	listedAsc, totalAsc, errAsc := ListQuestions(map[string]interface{}{}, "subject", "ASC", 10, 1)
	if errAsc != nil { t.Fatalf("SortBySubject ASC failed: %v", errAsc) }
	if totalAsc != 3 || len(listedAsc) != 3 { t.Fatalf("SortBySubject ASC: Expected total 3, len 3. Got T:%d, L:%d", totalAsc, len(listedAsc)) }
	if listedAsc[0].ID != qBioID || listedAsc[1].ID != qChemID || listedAsc[2].ID != qPhysID {
		t.Errorf("SortBySubject ASC order incorrect. Got IDs: %s (%s), %s (%s), %s (%s). Expected: %s, %s, %s", listedAsc[0].ID, listedAsc[0].Subject, listedAsc[1].ID, listedAsc[1].Subject, listedAsc[2].ID, listedAsc[2].Subject, qBioID, qChemID, qPhysID)
	}

	listedDesc, totalDesc, errDesc := ListQuestions(map[string]interface{}{}, "subject", "DESC", 10, 1)
	if errDesc != nil { t.Fatalf("SortBySubject DESC failed: %v", errDesc) }
	if totalDesc != 3 || len(listedDesc) != 3 { t.Fatalf("SortBySubject DESC: Expected total 3, len 3. Got T:%d, L:%d", totalDesc, len(listedDesc)) }
	if listedDesc[0].ID != qPhysID || listedDesc[1].ID != qChemID || listedDesc[2].ID != qBioID {
		t.Errorf("SortBySubject DESC order incorrect. Got IDs: %s (%s), %s (%s), %s (%s). Expected: %s, %s, %s", listedDesc[0].ID, listedDesc[0].Subject, listedDesc[1].ID, listedDesc[1].Subject, listedDesc[2].ID, listedDesc[2].Subject, qPhysID, qChemID, qBioID)
	}
}

func TestListQuestions_SortByDifficulty(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	qEasyID, _ := CreateQuestion(models.Question{Difficulty: models.DifficultyEasy, Subject: "DiffEasy", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	qHardID, _ := CreateQuestion(models.Question{Difficulty: models.DifficultyHard, Subject: "DiffHard", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	qMediumID, _ := CreateQuestion(models.Question{Difficulty: models.DifficultyMedium, Subject: "DiffMed", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})

	listedAsc, totalAsc, errAsc := ListQuestions(map[string]interface{}{}, "difficulty", "ASC", 10, 1)
	if errAsc != nil { t.Fatalf("SortByDifficulty ASC failed: %v", errAsc) }
	if totalAsc != 3 || len(listedAsc) != 3 { t.Fatalf("SortByDifficulty ASC: Expected total 3, len 3. Got T:%d, L:%d", totalAsc, len(listedAsc)) }
	expectedOrderASC_IDs := []string{qEasyID, qHardID, qMediumID}
	for i, qID := range expectedOrderASC_IDs {
		if listedAsc[i].ID != qID { t.Errorf("SortByDifficulty ASC order error at index %d. Got ID %s (Diff: %s), want ID %s", i, listedAsc[i].ID, listedAsc[i].Difficulty, qID) }
	}

	listedDesc, totalDesc, errDesc := ListQuestions(map[string]interface{}{}, "difficulty", "DESC", 10, 1)
	if errDesc != nil { t.Fatalf("SortByDifficulty DESC failed: %v", errDesc) }
	if totalDesc != 3 || len(listedDesc) != 3 { t.Fatalf("SortByDifficulty DESC: Expected total 3, len 3. Got T:%d, L:%d", totalDesc, len(listedDesc)) }
	expectedOrderDESC_IDs := []string{qMediumID, qHardID, qEasyID}
	for i, qID := range expectedOrderDESC_IDs {
		if listedDesc[i].ID != qID { t.Errorf("SortByDifficulty DESC order error at index %d. Got ID %s (Diff: %s), want ID %s", i, listedDesc[i].ID, listedDesc[i].Difficulty, qID) }
	}
}

func TestListQuestions_SortByAuthor(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	qAliceID, _ := CreateQuestion(models.Question{Author: "Alice", Subject: "Auth1", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	qBobID, _ := CreateQuestion(models.Question{Author: "Bob", Subject: "Auth2", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	qZorroID, _ := CreateQuestion(models.Question{Author: "Zorro", Subject: "Auth3", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})

	listedAsc, totalAsc, errAsc := ListQuestions(map[string]interface{}{}, "author", "ASC", 10, 1)
	if errAsc != nil { t.Fatalf("SortByAuthor ASC failed: %v", errAsc) }
	if totalAsc != 3 || len(listedAsc) != 3 { t.Fatalf("SortByAuthor ASC: Expected total 3, len 3. Got T:%d, L:%d", totalAsc, len(listedAsc)) }
	if listedAsc[0].ID != qAliceID || listedAsc[1].ID != qBobID || listedAsc[2].ID != qZorroID {
		t.Errorf("SortByAuthor ASC order incorrect. Got Authors: %s, %s, %s", listedAsc[0].Author, listedAsc[1].Author, listedAsc[2].Author)
	}
}

func TestListQuestions_SortByLastUsedAt(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	now := time.Now().UTC().Truncate(time.Second)
	qT1ID, _ := CreateQuestion(models.Question{LastUsedAt: now.Add(-3 * time.Hour), Subject: "LU_Oldest", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	qT3ID, _ := CreateQuestion(models.Question{LastUsedAt: now.Add(-1 * time.Hour), Subject: "LU_Newest", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	qT2ID, _ := CreateQuestion(models.Question{LastUsedAt: now.Add(-2 * time.Hour), Subject: "LU_Middle", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})
	qTZeroID, _ := CreateQuestion(models.Question{LastUsedAt: time.Time{}, Subject: "LU_Zero", CorrectAnswers: []string{"a"}, QuestionType: "t", CreatedAt: time.Now()})

	listedAsc, totalAsc, errAsc := ListQuestions(map[string]interface{}{}, "last_used_at", "ASC", 10, 1)
	if errAsc != nil { t.Fatalf("SortByLastUsedAt ASC failed: %v", errAsc) }
	if totalAsc != 4 || len(listedAsc) != 4 { t.Fatalf("SortByLastUsedAt ASC: Expected total 4, len 4. Got T:%d, L:%d", totalAsc, len(listedAsc)) }
	expectedOrderASC_IDs := []string{qTZeroID, qT1ID, qT2ID, qT3ID}
	for i, qID := range expectedOrderASC_IDs {
		if listedAsc[i].ID != qID { t.Errorf("SortByLastUsedAt ASC order error at index %d. Got ID %s (LU: %v), want ID %s", i, listedAsc[i].ID, listedAsc[i].LastUsedAt, qID) }
	}

	listedDesc, totalDesc, errDesc := ListQuestions(map[string]interface{}{}, "last_used_at", "DESC", 10, 1)
	if errDesc != nil { t.Fatalf("SortByLastUsedAt DESC failed: %v", errDesc) }
	if totalDesc != 4 || len(listedDesc) != 4 { t.Fatalf("SortByLastUsedAt DESC: Expected total 4, len 4. Got T:%d, L:%d", totalDesc, len(listedDesc)) }
	expectedOrderDESC_IDs := []string{qT3ID, qT2ID, qT1ID, qTZeroID}
	for i, qID := range expectedOrderDESC_IDs {
		if listedDesc[i].ID != qID { t.Errorf("SortByLastUsedAt DESC order error at index %d. Got ID %s (LU: %v), want ID %s", i, listedDesc[i].ID, listedDesc[i].LastUsedAt, qID) }
	}
}

func TestListQuestions_SortByInvalidColumn(t *testing.T) {
	if err := clearQuestionsTable(); err != nil { t.Fatalf("Failed to clear questions table: %v", err) }
	_, _, err := ListQuestions(map[string]interface{}{}, "non_existent_column", "ASC", 10, 1)
	if err == nil {
		t.Fatal("Expected error for invalid sort column, got nil")
	}
	expectedErrorMsg := "invalid sort_by column"
	if !strings.Contains(err.Error(), expectedErrorMsg) {
		t.Errorf("Expected error message to contain '%s', got '%s'", expectedErrorMsg, err.Error())
	}
}
